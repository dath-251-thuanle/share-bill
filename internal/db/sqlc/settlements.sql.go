// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: settlements.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCollector = `-- name: CreateCollector :one
INSERT INTO collectors (
    event_id, participant_id, bank_name, bank_account, bank_owner, is_active
) VALUES (
    $1, $2, $3, $4, $5, TRUE
) RETURNING collector_id, collector_uuid, event_id, participant_id, bank_name, bank_account, bank_owner, assigned_at, ended_at, is_active
`

type CreateCollectorParams struct {
	EventID       int64  `json:"event_id"`
	ParticipantID *int64 `json:"participant_id"`
	BankName      string `json:"bank_name"`
	BankAccount   string `json:"bank_account"`
	BankOwner     string `json:"bank_owner"`
}

func (q *Queries) CreateCollector(ctx context.Context, arg CreateCollectorParams) (Collector, error) {
	row := q.db.QueryRow(ctx, createCollector,
		arg.EventID,
		arg.ParticipantID,
		arg.BankName,
		arg.BankAccount,
		arg.BankOwner,
	)
	var i Collector
	err := row.Scan(
		&i.CollectorID,
		&i.CollectorUuid,
		&i.EventID,
		&i.ParticipantID,
		&i.BankName,
		&i.BankAccount,
		&i.BankOwner,
		&i.AssignedAt,
		&i.EndedAt,
		&i.IsActive,
	)
	return i, err
}

const createSettlement = `-- name: CreateSettlement :one
INSERT INTO settlements (
    event_id, settlement_uuid, payer_id, receiver_id, amount
) VALUES (
    $1, gen_random_uuid(), $2, $3, $4
) RETURNING settlement_id, settlement_uuid, event_id, amount, created_at, payer_id, receiver_id
`

type CreateSettlementParams struct {
	EventID    int64          `json:"event_id"`
	PayerID    *int64         `json:"payer_id"`
	ReceiverID *int64         `json:"receiver_id"`
	Amount     pgtype.Numeric `json:"amount"`
}

func (q *Queries) CreateSettlement(ctx context.Context, arg CreateSettlementParams) (Settlement, error) {
	row := q.db.QueryRow(ctx, createSettlement,
		arg.EventID,
		arg.PayerID,
		arg.ReceiverID,
		arg.Amount,
	)
	var i Settlement
	err := row.Scan(
		&i.SettlementID,
		&i.SettlementUuid,
		&i.EventID,
		&i.Amount,
		&i.CreatedAt,
		&i.PayerID,
		&i.ReceiverID,
	)
	return i, err
}

const deactivateCollector = `-- name: DeactivateCollector :exec
UPDATE collectors
SET is_active = FALSE, ended_at = NOW()
WHERE collector_id = $1
`

func (q *Queries) DeactivateCollector(ctx context.Context, collectorID int64) error {
	_, err := q.db.Exec(ctx, deactivateCollector, collectorID)
	return err
}

const deleteSettlement = `-- name: DeleteSettlement :exec
DELETE FROM settlements WHERE settlement_id = $1
`

func (q *Queries) DeleteSettlement(ctx context.Context, settlementID int64) error {
	_, err := q.db.Exec(ctx, deleteSettlement, settlementID)
	return err
}

const getActiveCollectorByEventID = `-- name: GetActiveCollectorByEventID :one
SELECT 
    c.collector_id, 
    c.bank_name, 
    c.bank_account, 
    c.bank_owner,
    p.participant_uuid, 
    p.name as participant_name
FROM collectors c
JOIN participants p ON c.participant_id = p.participant_id
WHERE c.event_id = $1 AND c.is_active = TRUE
LIMIT 1
`

type GetActiveCollectorByEventIDRow struct {
	CollectorID     int64     `json:"collector_id"`
	BankName        string    `json:"bank_name"`
	BankAccount     string    `json:"bank_account"`
	BankOwner       string    `json:"bank_owner"`
	ParticipantUuid uuid.UUID `json:"participant_uuid"`
	ParticipantName string    `json:"participant_name"`
}

func (q *Queries) GetActiveCollectorByEventID(ctx context.Context, eventID int64) (GetActiveCollectorByEventIDRow, error) {
	row := q.db.QueryRow(ctx, getActiveCollectorByEventID, eventID)
	var i GetActiveCollectorByEventIDRow
	err := row.Scan(
		&i.CollectorID,
		&i.BankName,
		&i.BankAccount,
		&i.BankOwner,
		&i.ParticipantUuid,
		&i.ParticipantName,
	)
	return i, err
}

const getEventBalances = `-- name: GetEventBalances :many
SELECT 
    p.participant_id,
    p.participant_uuid,
    p.name,
    p.user_id,
    COALESCE((
        SELECT SUM(ep.paid_amount) 
        FROM expense_payers ep 
        JOIN expenses e ON ep.expense_id = e.expense_id 
        WHERE ep.participant_id = p.participant_id AND e.event_id = $1
    ), 0)::numeric as total_paid,
    COALESCE((
        SELECT SUM(e.total_amount * eb.split_ratio) 
        FROM expense_beneficiaries eb 
        JOIN expenses e ON eb.expense_id = e.expense_id 
        WHERE eb.participant_id = p.participant_id AND e.event_id = $1
    ), 0)::numeric as total_share,
    COALESCE((
        SELECT SUM(s.amount) 
        FROM settlements s 
        WHERE s.payer_id = p.participant_id AND s.event_id = $1
    ), 0)::numeric as total_settled_sent,
    COALESCE((
        SELECT SUM(s.amount) 
        FROM settlements s 
        WHERE s.receiver_id = p.participant_id AND s.event_id = $1
    ), 0)::numeric as total_settled_received
FROM participants p
WHERE p.event_id = $1
`

type GetEventBalancesRow struct {
	ParticipantID        int64          `json:"participant_id"`
	ParticipantUuid      uuid.UUID      `json:"participant_uuid"`
	Name                 string         `json:"name"`
	UserID               *int64         `json:"user_id"`
	TotalPaid            pgtype.Numeric `json:"total_paid"`
	TotalShare           pgtype.Numeric `json:"total_share"`
	TotalSettledSent     pgtype.Numeric `json:"total_settled_sent"`
	TotalSettledReceived pgtype.Numeric `json:"total_settled_received"`
}

func (q *Queries) GetEventBalances(ctx context.Context, eventID int64) ([]GetEventBalancesRow, error) {
	rows, err := q.db.Query(ctx, getEventBalances, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventBalancesRow
	for rows.Next() {
		var i GetEventBalancesRow
		if err := rows.Scan(
			&i.ParticipantID,
			&i.ParticipantUuid,
			&i.Name,
			&i.UserID,
			&i.TotalPaid,
			&i.TotalShare,
			&i.TotalSettledSent,
			&i.TotalSettledReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSettlementsByEvent = `-- name: ListSettlementsByEvent :many
SELECT 
    s.settlement_id, s.settlement_uuid, s.amount, s.created_at,
    p_payer.name as payer_name, p_payer.participant_uuid as payer_uuid,
    p_receiver.name as receiver_name, p_receiver.participant_uuid as receiver_uuid
FROM settlements s
JOIN participants p_payer ON s.payer_id = p_payer.participant_id
JOIN participants p_receiver ON s.receiver_id = p_receiver.participant_id
WHERE s.event_id = $1
ORDER BY s.created_at DESC
`

type ListSettlementsByEventRow struct {
	SettlementID   int64              `json:"settlement_id"`
	SettlementUuid uuid.UUID          `json:"settlement_uuid"`
	Amount         pgtype.Numeric     `json:"amount"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	PayerName      string             `json:"payer_name"`
	PayerUuid      uuid.UUID          `json:"payer_uuid"`
	ReceiverName   string             `json:"receiver_name"`
	ReceiverUuid   uuid.UUID          `json:"receiver_uuid"`
}

func (q *Queries) ListSettlementsByEvent(ctx context.Context, eventID int64) ([]ListSettlementsByEventRow, error) {
	rows, err := q.db.Query(ctx, listSettlementsByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSettlementsByEventRow
	for rows.Next() {
		var i ListSettlementsByEventRow
		if err := rows.Scan(
			&i.SettlementID,
			&i.SettlementUuid,
			&i.Amount,
			&i.CreatedAt,
			&i.PayerName,
			&i.PayerUuid,
			&i.ReceiverName,
			&i.ReceiverUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
