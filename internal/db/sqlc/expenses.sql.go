// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: expenses.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (
    event_id, description, total_amount, created_at, expense_uuid
) VALUES (
    $1, $2, $3, NOW(), gen_random_uuid()
) RETURNING expense_id, expense_uuid, event_id, description, total_amount, created_at
`

type CreateExpenseParams struct {
	EventID     int64          `json:"event_id"`
	Description string         `json:"description"`
	TotalAmount pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRow(ctx, createExpense, arg.EventID, arg.Description, arg.TotalAmount)
	var i Expense
	err := row.Scan(
		&i.ExpenseID,
		&i.ExpenseUuid,
		&i.EventID,
		&i.Description,
		&i.TotalAmount,
		&i.CreatedAt,
	)
	return i, err
}

const createExpenseBeneficiary = `-- name: CreateExpenseBeneficiary :exec
INSERT INTO expense_beneficiaries (
    expense_id, participant_id, split_ratio, beneficiary_uuid
) VALUES (
    $1, $2, $3, gen_random_uuid()
)
`

type CreateExpenseBeneficiaryParams struct {
	ExpenseID     *int64         `json:"expense_id"`
	ParticipantID *int64         `json:"participant_id"`
	SplitRatio    pgtype.Numeric `json:"split_ratio"`
}

func (q *Queries) CreateExpenseBeneficiary(ctx context.Context, arg CreateExpenseBeneficiaryParams) error {
	_, err := q.db.Exec(ctx, createExpenseBeneficiary, arg.ExpenseID, arg.ParticipantID, arg.SplitRatio)
	return err
}

const createExpensePayer = `-- name: CreateExpensePayer :exec
INSERT INTO expense_payers (
    expense_id, participant_id, paid_amount, payer_uuid
) VALUES (
    $1, $2, $3, gen_random_uuid()
)
`

type CreateExpensePayerParams struct {
	ExpenseID     int64          `json:"expense_id"`
	ParticipantID *int64         `json:"participant_id"`
	PaidAmount    pgtype.Numeric `json:"paid_amount"`
}

func (q *Queries) CreateExpensePayer(ctx context.Context, arg CreateExpensePayerParams) error {
	_, err := q.db.Exec(ctx, createExpensePayer, arg.ExpenseID, arg.ParticipantID, arg.PaidAmount)
	return err
}

const deleteExpense = `-- name: DeleteExpense :exec
DELETE FROM expenses WHERE expense_id = $1
`

func (q *Queries) DeleteExpense(ctx context.Context, expenseID int64) error {
	_, err := q.db.Exec(ctx, deleteExpense, expenseID)
	return err
}

const deleteExpenseBeneficiaries = `-- name: DeleteExpenseBeneficiaries :exec
DELETE FROM expense_beneficiaries WHERE expense_id = $1
`

func (q *Queries) DeleteExpenseBeneficiaries(ctx context.Context, expenseID *int64) error {
	_, err := q.db.Exec(ctx, deleteExpenseBeneficiaries, expenseID)
	return err
}

const deleteExpensePayers = `-- name: DeleteExpensePayers :exec
DELETE FROM expense_payers WHERE expense_id = $1
`

func (q *Queries) DeleteExpensePayers(ctx context.Context, expenseID int64) error {
	_, err := q.db.Exec(ctx, deleteExpensePayers, expenseID)
	return err
}

const getExpenseBeneficiaries = `-- name: GetExpenseBeneficiaries :many
SELECT eb.split_ratio, p.participant_uuid, p.name
FROM expense_beneficiaries eb
JOIN participants p ON eb.participant_id = p.participant_id
WHERE eb.expense_id = $1
`

type GetExpenseBeneficiariesRow struct {
	SplitRatio      pgtype.Numeric `json:"split_ratio"`
	ParticipantUuid uuid.UUID      `json:"participant_uuid"`
	Name            string         `json:"name"`
}

func (q *Queries) GetExpenseBeneficiaries(ctx context.Context, expenseID *int64) ([]GetExpenseBeneficiariesRow, error) {
	rows, err := q.db.Query(ctx, getExpenseBeneficiaries, expenseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpenseBeneficiariesRow
	for rows.Next() {
		var i GetExpenseBeneficiariesRow
		if err := rows.Scan(&i.SplitRatio, &i.ParticipantUuid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpenseByUUID = `-- name: GetExpenseByUUID :one
SELECT expense_id, expense_uuid, event_id, description, total_amount, created_at FROM expenses WHERE expense_uuid = $1
`

func (q *Queries) GetExpenseByUUID(ctx context.Context, expenseUuid uuid.UUID) (Expense, error) {
	row := q.db.QueryRow(ctx, getExpenseByUUID, expenseUuid)
	var i Expense
	err := row.Scan(
		&i.ExpenseID,
		&i.ExpenseUuid,
		&i.EventID,
		&i.Description,
		&i.TotalAmount,
		&i.CreatedAt,
	)
	return i, err
}

const getExpensePayers = `-- name: GetExpensePayers :many
SELECT ep.paid_amount, p.participant_uuid, p.name
FROM expense_payers ep
JOIN participants p ON ep.participant_id = p.participant_id
WHERE ep.expense_id = $1
`

type GetExpensePayersRow struct {
	PaidAmount      pgtype.Numeric `json:"paid_amount"`
	ParticipantUuid uuid.UUID      `json:"participant_uuid"`
	Name            string         `json:"name"`
}

func (q *Queries) GetExpensePayers(ctx context.Context, expenseID int64) ([]GetExpensePayersRow, error) {
	rows, err := q.db.Query(ctx, getExpensePayers, expenseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensePayersRow
	for rows.Next() {
		var i GetExpensePayersRow
		if err := rows.Scan(&i.PaidAmount, &i.ParticipantUuid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpensesByEventID = `-- name: ListExpensesByEventID :many
SELECT 
    x.expense_id, x.expense_uuid, x.description, x.total_amount, x.created_at,
    (SELECT p.name FROM expense_payers ep JOIN participants p ON ep.participant_id = p.participant_id WHERE ep.expense_id = x.expense_id LIMIT 1) as payer_name
FROM expenses x
WHERE x.event_id = $1
ORDER BY x.created_at DESC
`

type ListExpensesByEventIDRow struct {
	ExpenseID   int64              `json:"expense_id"`
	ExpenseUuid uuid.UUID          `json:"expense_uuid"`
	Description string             `json:"description"`
	TotalAmount pgtype.Numeric     `json:"total_amount"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	PayerName   string             `json:"payer_name"`
}

func (q *Queries) ListExpensesByEventID(ctx context.Context, eventID int64) ([]ListExpensesByEventIDRow, error) {
	rows, err := q.db.Query(ctx, listExpensesByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExpensesByEventIDRow
	for rows.Next() {
		var i ListExpensesByEventIDRow
		if err := rows.Scan(
			&i.ExpenseID,
			&i.ExpenseUuid,
			&i.Description,
			&i.TotalAmount,
			&i.CreatedAt,
			&i.PayerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpense = `-- name: UpdateExpense :one
UPDATE expenses
SET 
    description = $2,
    total_amount = $3
WHERE expense_id = $1
RETURNING expense_id, expense_uuid, event_id, description, total_amount, created_at
`

type UpdateExpenseParams struct {
	ExpenseID   int64          `json:"expense_id"`
	Description string         `json:"description"`
	TotalAmount pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) (Expense, error) {
	row := q.db.QueryRow(ctx, updateExpense, arg.ExpenseID, arg.Description, arg.TotalAmount)
	var i Expense
	err := row.Scan(
		&i.ExpenseID,
		&i.ExpenseUuid,
		&i.EventID,
		&i.Description,
		&i.TotalAmount,
		&i.CreatedAt,
	)
	return i, err
}
