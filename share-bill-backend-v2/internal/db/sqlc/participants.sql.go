// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: participants.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addParticipant = `-- name: AddParticipant :one
INSERT INTO participants (
    event_id, user_id, name, bank_name, bank_account, bank_owner
) VALUES (
    $1, $3, $2, $4, $5, $6
) RETURNING participant_id, participant_uuid, event_id, user_id, name, bank_name, bank_account, bank_owner, joined_at
`

type AddParticipantParams struct {
	EventID     int64   `json:"event_id"`
	Name        string  `json:"name"`
	UserID      *int64  `json:"user_id"`
	BankName    *string `json:"bank_name"`
	BankAccount *string `json:"bank_account"`
	BankOwner   *string `json:"bank_owner"`
}

func (q *Queries) AddParticipant(ctx context.Context, arg AddParticipantParams) (Participant, error) {
	row := q.db.QueryRow(ctx, addParticipant,
		arg.EventID,
		arg.Name,
		arg.UserID,
		arg.BankName,
		arg.BankAccount,
		arg.BankOwner,
	)
	var i Participant
	err := row.Scan(
		&i.ParticipantID,
		&i.ParticipantUuid,
		&i.EventID,
		&i.UserID,
		&i.Name,
		&i.BankName,
		&i.BankAccount,
		&i.BankOwner,
		&i.JoinedAt,
	)
	return i, err
}

const getParticipantBalance = `-- name: GetParticipantBalance :one
SELECT 
    (
        -- 1. Tổng tiền người này đã chi (Paid)
        COALESCE((
            SELECT SUM(ep.paid_amount)
            FROM expense_payers ep
            -- JOIN bảng participants để xác định đúng user_id và event_id
            JOIN participants p_payer ON ep.participant_id = p_payer.participant_id
            WHERE p_payer.event_id = $1 AND p_payer.user_id = $2
        ), 0) 
        - 
        -- 2. Tổng tiền người này phải chịu (Owed/Benefit)
        -- Công thức: Tổng (Giá trị Hóa đơn * Tỷ lệ chia)
        COALESCE((
            SELECT SUM(e.total_amount * eb.split_ratio)
            FROM expense_beneficiaries eb
            JOIN expenses e ON eb.expense_id = e.expense_id
            JOIN participants p_ben ON eb.participant_id = p_ben.participant_id
            WHERE p_ben.event_id = $1 AND p_ben.user_id = $2
        ), 0)
    )::numeric AS balance
`

type GetParticipantBalanceParams struct {
	EventID int64  `json:"event_id"`
	UserID  *int64 `json:"user_id"`
}

func (q *Queries) GetParticipantBalance(ctx context.Context, arg GetParticipantBalanceParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getParticipantBalance, arg.EventID, arg.UserID)
	var balance pgtype.Numeric
	err := row.Scan(&balance)
	return balance, err
}

const getParticipantByEventAndUser = `-- name: GetParticipantByEventAndUser :one
SELECT participant_id, participant_uuid, event_id, user_id, name, bank_name, bank_account, bank_owner, joined_at FROM participants
WHERE event_id = $1 AND user_id = $2 LIMIT 1
`

type GetParticipantByEventAndUserParams struct {
	EventID int64  `json:"event_id"`
	UserID  *int64 `json:"user_id"`
}

func (q *Queries) GetParticipantByEventAndUser(ctx context.Context, arg GetParticipantByEventAndUserParams) (Participant, error) {
	row := q.db.QueryRow(ctx, getParticipantByEventAndUser, arg.EventID, arg.UserID)
	var i Participant
	err := row.Scan(
		&i.ParticipantID,
		&i.ParticipantUuid,
		&i.EventID,
		&i.UserID,
		&i.Name,
		&i.BankName,
		&i.BankAccount,
		&i.BankOwner,
		&i.JoinedAt,
	)
	return i, err
}

const getParticipantByID = `-- name: GetParticipantByID :one
SELECT participant_id, participant_uuid, event_id, user_id, name, bank_name, bank_account, bank_owner, joined_at FROM participants
WHERE participant_id = $1 LIMIT 1
`

func (q *Queries) GetParticipantByID(ctx context.Context, participantID int64) (Participant, error) {
	row := q.db.QueryRow(ctx, getParticipantByID, participantID)
	var i Participant
	err := row.Scan(
		&i.ParticipantID,
		&i.ParticipantUuid,
		&i.EventID,
		&i.UserID,
		&i.Name,
		&i.BankName,
		&i.BankAccount,
		&i.BankOwner,
		&i.JoinedAt,
	)
	return i, err
}

const getParticipantByUUID = `-- name: GetParticipantByUUID :one
SELECT participant_id, participant_uuid, event_id, user_id, name, bank_name, bank_account, bank_owner, joined_at FROM participants WHERE participant_uuid = $1 LIMIT 1
`

func (q *Queries) GetParticipantByUUID(ctx context.Context, participantUuid uuid.UUID) (Participant, error) {
	row := q.db.QueryRow(ctx, getParticipantByUUID, participantUuid)
	var i Participant
	err := row.Scan(
		&i.ParticipantID,
		&i.ParticipantUuid,
		&i.EventID,
		&i.UserID,
		&i.Name,
		&i.BankName,
		&i.BankAccount,
		&i.BankOwner,
		&i.JoinedAt,
	)
	return i, err
}

const listParticipantsByEventID = `-- name: ListParticipantsByEventID :many
SELECT 
    p.participant_id, p.participant_uuid, p.event_id, p.user_id, p.name, p.bank_name, p.bank_account, p.bank_owner, p.joined_at,
    u.user_uuid as user_global_uuid,
    u.email as user_email
FROM participants p
LEFT JOIN users u ON p.user_id = u.user_id
WHERE p.event_id = $1
ORDER BY p.joined_at ASC
`

type ListParticipantsByEventIDRow struct {
	ParticipantID   int64              `json:"participant_id"`
	ParticipantUuid uuid.UUID          `json:"participant_uuid"`
	EventID         int64              `json:"event_id"`
	UserID          *int64             `json:"user_id"`
	Name            string             `json:"name"`
	BankName        *string            `json:"bank_name"`
	BankAccount     *string            `json:"bank_account"`
	BankOwner       *string            `json:"bank_owner"`
	JoinedAt        pgtype.Timestamptz `json:"joined_at"`
	UserGlobalUuid  pgtype.UUID        `json:"user_global_uuid"`
	UserEmail       *string            `json:"user_email"`
}

func (q *Queries) ListParticipantsByEventID(ctx context.Context, eventID int64) ([]ListParticipantsByEventIDRow, error) {
	rows, err := q.db.Query(ctx, listParticipantsByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListParticipantsByEventIDRow
	for rows.Next() {
		var i ListParticipantsByEventIDRow
		if err := rows.Scan(
			&i.ParticipantID,
			&i.ParticipantUuid,
			&i.EventID,
			&i.UserID,
			&i.Name,
			&i.BankName,
			&i.BankAccount,
			&i.BankOwner,
			&i.JoinedAt,
			&i.UserGlobalUuid,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeParticipant = `-- name: RemoveParticipant :exec
DELETE FROM participants WHERE event_id = $1 AND user_id = $2
`

type RemoveParticipantParams struct {
	EventID int64  `json:"event_id"`
	UserID  *int64 `json:"user_id"`
}

func (q *Queries) RemoveParticipant(ctx context.Context, arg RemoveParticipantParams) error {
	_, err := q.db.Exec(ctx, removeParticipant, arg.EventID, arg.UserID)
	return err
}

const removeParticipantByID = `-- name: RemoveParticipantByID :exec
DELETE FROM participants WHERE participant_id = $1
`

func (q *Queries) RemoveParticipantByID(ctx context.Context, participantID int64) error {
	_, err := q.db.Exec(ctx, removeParticipantByID, participantID)
	return err
}

const updateParticipant = `-- name: UpdateParticipant :one
UPDATE participants
SET 
    name = COALESCE($2, name),
    bank_name = COALESCE($3, bank_name),
    bank_account = COALESCE($4, bank_account),
    bank_owner = COALESCE($5, bank_owner)
WHERE participant_id = $1
RETURNING participant_id, participant_uuid, event_id, user_id, name, bank_name, bank_account, bank_owner, joined_at
`

type UpdateParticipantParams struct {
	ParticipantID int64   `json:"participant_id"`
	Name          *string `json:"name"`
	BankName      *string `json:"bank_name"`
	BankAccount   *string `json:"bank_account"`
	BankOwner     *string `json:"bank_owner"`
}

func (q *Queries) UpdateParticipant(ctx context.Context, arg UpdateParticipantParams) (Participant, error) {
	row := q.db.QueryRow(ctx, updateParticipant,
		arg.ParticipantID,
		arg.Name,
		arg.BankName,
		arg.BankAccount,
		arg.BankOwner,
	)
	var i Participant
	err := row.Scan(
		&i.ParticipantID,
		&i.ParticipantUuid,
		&i.EventID,
		&i.UserID,
		&i.Name,
		&i.BankName,
		&i.BankAccount,
		&i.BankOwner,
		&i.JoinedAt,
	)
	return i, err
}
